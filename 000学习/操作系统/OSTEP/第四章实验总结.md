### 实验结论总结：进程调度与 I/O 行为

通过对 `process-run.py` 模拟器的实验，我们可以得出以下关于操作系统进程调度的关键结论：

#### 1. CPU 利用率与进程类型

- **问题 1**: 当所有进程都是 **I/O 密集型**（`5:100`）时，CPU 利用率并不高。
    
    - **结论**：这是因为 I/O 密集型进程的大部分时间都花在**等待 I/O 完成**上，而不是使用 CPU 进行计算。当一个进程发出 I/O 请求后，它会进入阻塞状态，此时 CPU 处于空闲或等待其他任务可用的状态。
        
    - **原理**：I/O 操作是物理性的，需要时间，而 CPU 在此期间无法继续为该进程服务。如果系统中只有 I/O 密集型进程，且只有一个 CPU，那么在 I/O 等待期间，CPU 的利用率会很低。
        

#### 2. 调度顺序的重要性

- **问题 2 & 3**: 在默认调度策略下（通常是 FCFS，先来先服务），**进程的顺序对总完成时间至关重要**。
    
    - **结论**：
        
        - 运行 `4:100,1:0` 时，I/O 密集型进程（`4:100`）先运行。它会发出 I/O 请求并等待，由于模拟器默认会等待 I/O 完成，这会占用较长时间，导致后面的 CPU 密集型进程（`1:0`）不得不长时间等待。
            
        - 运行 `1:0,4:100` 时，CPU 密集型进程（`1:0`）先运行。它会很快地完成其 CPU 指令，然后立即退出，从而让 I/O 密集型进程（`4:100`）能够早点开始执行。
            
    - **原理**：这个实验证明了 **FCFS 调度策略存在“护航效应”（convoy effect）**。一个耗时长的进程（即使它大部分时间在等待）会“护航”在队列前面，导致后面耗时短的进程无法及时获得资源。
        

#### 3. I/O 发生时的切换行为

- **问题 4 & 5**: 操作系统在进程发出 I/O 请求时的行为对系统效率影响巨大。
    
    - **结论**：
        
        - **`SWITCH_ON_END`**: 当 I/O 发生时，系统会**忙等**该进程直到其 I/O 完成。这会浪费宝贵的 CPU 时间，因为 CPU 在等待 I/O 期间本可以运行其他进程。
            
        - **`SWITCH_ON_IO`**: 当 I/O 发生时，系统会立即将该进程切换到阻塞状态，并调度其他就绪进程运行。这有效地利用了 CPU，提高了系统的整体效率。
            
    - **原理**：`SWITCH_ON_IO` 体现了**多任务处理**的核心思想：在等待耗时操作时，不让 CPU 空闲，而是切换去处理其他有用的工作。这大大提高了系统的吞吐量。
        

#### 4. I/O 完成后的调度行为

- **问题 6 & 7**: 当一个进程的 I/O 完成时，调度器如何处理该进程会影响系统的公平性和响应时间。
    
    - **结论**：
        
        - **`IO_RUN_LATER`**: I/O 完成后，发出 I/O 的进程被放入就绪队列，但**不会立即运行**。CPU 会继续运行当前正在执行的进程。这保证了当前进程的完整执行，但可能会让刚刚完成 I/O 的进程等待更长时间，影响其响应时间。
            
        - **`IO_RUN_IMMEDIATE`**: I/O 完成后，发出 I/O 的进程会**立即抢占 CPU 运行**。这能大大减少 I/O 密集型进程的等待时间，提高了响应速度。
            
    - **原理**：`IO_RUN_IMMEDIATE` 类似于 **优先级反转**，即给刚刚完成 I/O 的进程一个临时的高优先级。这对于 I/O 密集型进程特别有利，因为它能立即处理刚刚获得的 I/O 数据，然后再次发出 I/O 请求，使得 CPU 和 I/O 设备能够更高效地协同工作。
        

#### 5. 综合策略对随机进程的影响

- **问题 8**: 当面临随机生成的、I/O 和 CPU 混合的进程时，不同的调度策略组合会产生不同的效果。
    
    - **结论**：
        
        - `SWITCH_ON_IO` + `IO_RUN_IMMEDIATE` 的组合通常能获得更高的 CPU 利用率和更公平的调度。当一个进程发出 I/O 时，CPU 不会空闲，会切换到其他进程。当一个进程的 I/O 完成时，它能立即获得 CPU，减少等待时间。
            
        - `SWITCH_ON_END` + `IO_RUN_LATER` 的组合则会产生更多的 CPU 空闲时间，并且由于进程长时间霸占 CPU，可能会导致某些进程饥饿，整体效率较低。
            
    - **原理**：优秀的调度策略需要**兼顾效率和公平性**。它应该能够在进程需要等待时及时让出 CPU，并在进程就绪后尽快给予 CPU，从而让系统资源得到最大化的利用。
        

总而言之，这些实验表明，一个高效的操作系统调度器需要在**进程执行 I/O 时主动切换**，并且在 **I/O 完成后能快速响应**，以确保 CPU 不被浪费，同时提高系统的吞吐量和响应速度。