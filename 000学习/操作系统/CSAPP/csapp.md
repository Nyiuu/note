# ==1 计算机系统漫游 ==

- ## ==1.1信息就是位+上下文== 
	- 文本文件：仅由ASCII字符构成
	- 二进制文件：其他
	- 区分不同数据对象的唯一方法：上下文
- ## ==1.2 程序被其他程序翻译成不同形式==
	- 预处理阶段：将头文件插入程序 hello.c -> hello.i(另一个C程序)
	- 编译额段： 编译器(ccl) hello.i -> hello.s(汇编语言程序)
		- 不同编译器在此阶段采用同样的汇编语言
	- 汇编阶段：汇编器(as)将 hello.s -> hello.o(可重定位目标程序)
	- 链接阶段：连接器(ld)将库中的函数与hello.o合并 hello.o + printf.o -> hello(可执行文件)
- ## ==1.3 了解编译系统如何工作是大有益处的==
	- 可恶的作者成功勾起了我的好奇心
- ## ==1.4 处理器读并解释储存在内存中的指令==
	- shell：命令行解释器
	- ### ==1.4.1 系统的硬件组成==
		- 总线：贯穿系统的电子管道，在各个部件间传递信息
		- I/O设备：输入输出设备，通过控制器(主板上的芯片组)/适配器(插在主板插槽的卡)与总线连接
		- 主存：由一组DRAM(动态随机存取储存器)组成，存储器本质——线性的字节数组
		- 处理器(CPU)         ==*？有点就没看懂，后面应该会详细讲*==
	- ### ==1.4.2 运行hello程序==
		- 从键盘读取命令
		- 从磁盘加载可执行文件到主存
		- 将输出字符串从存储器写到显示器
- ## ==1.5 高速缓存至关重要==
	- 上节的示例揭示问题：复制来复制去开销大
	- 机械原理：大的储存设备运行慢（主存）
	- 通过让高速缓存器存放经常用到的数据提高访问速度
- ## ==1.6 存储设备形成层次结构== 
	- 更高一层是更低一层的高速缓存
	- 结构……
- ## ==1.7 操作系统管理硬件==
	- 操作系统连接硬件与软件
		- 作用1：防止失控应用滥用软件
		- 作用2：对低级硬件进行抽象
			- I/O设备->文件
			- 主存和磁盘I/O设备->虚拟内存
			- 处理器、主存和I/O设备->进程
	- ### ==1.7.1 进程==
		- 正在运行的程序的抽象
		- 上下文切换：处理器在进程间切换
		- 由内核管理
	- ### ==1.7.2 线程==
		- 进程由多个线程组成
		- 多线程使程序运行的更高效
	- ### ==1.7.3 虚拟内存==
		- 为每个进程提供一个假象：它独占内存
		- 从低到高：程序代码和数据-> 堆-> 共享库 -> 栈 -> 内核->虚拟内存
	- ### ==1.7.4 文件==
		- 字节序列
		- 所有输入输出看作系统函数调用读写文件
- ## ==1.8系统之间利用网络通信== 
- ## ==1.9 重要主题==
	- ### ==1.9.1 Amdahl定律==
		- 主要观点：要想显著加速整个系统，必须提升全系统中相当大的部分的加速度
		- 有趣的启示：学生想要提升自己的绩点平均值，需要提升大部分科目成绩
	- ### ==1.9.2 并发和并行==
		- 并发：一个同时具有多系统的过程
		- 并行：用并发使一个系统运行得更快
		- 1. 线程级并发：模拟出来的并发行为
			- 单核处理器
			- 多核处理器
			- 超线程：允许CPU执行多个控制流，能在单个周期的基础上决定要执行哪一个线程
		- 2. 指令级并行：处理器同时执行多条命令
			- 超标量：达到比一个周期处理一条指令更快的速率
		- 3. 单指令、多数据并行（SIMD）
	- ### ==1.9.3 计算机系统中抽象的重要性==
		- 好的编程习惯：为一组函数规定一个简单的API接口
		- 虚拟机：对整个计算机的抽象
	
	
- ### ==结束==
	- 经过这章对这本书有了初步的认识，感觉还是蛮有意思的，听说第二章劝退了很多想读这本书的人，究竟是为什么呢，有点好奇欸。                                                         ---2024/12/18
	
	
# ==2 信息的表示和处理==

- 二进制的优点：二值信号容易被表示、储存和运输
- 作者对于数学原理的阅读与学习建议：反复阅读原理描述和它的示例讨论直到有牢固的直觉（我也是这样想哒）
- C语言演变
- ## ==2.1 信息储存==
	- 计算机将内存视为非常大的字节数组：虚拟内存
	- 内存每个字节地址唯一，内存所有可能地址的集合：虚拟内存空间       Q：为什么是可能？
	- ### ==2.1.1 十六进制表示法==
		- 使用原因：描述位模式时二进制与十进制都不方便
		- 标志：0x或0X开头
		- 编写机器级程序的常见任务：不同进制相互转换	
			- 16-10转换：A-10  C-12  F-15
			- 10-16转换 短除法
			- 16-2转换：四位一组分组
			- 2-16转换：
				- 法一：四位一组分组
				- 法二：
					- n = i + 4j      
					- 2048 = x^11 
					- 11 = 3  + 4  * 2
					-  0x800（不太会用LaTeX，暂时自己看得懂就行嘻嘻）
	- ### ==2.1.2 字数据大小==
		- 字长指明指针数据的标称大小，决定虚拟地址空间的最大大小
		- 字长w位，虚拟地址范围0 ~ 2 ^w -1（32位机器最大4GB，这就是为啥要更新吗哈哈）
		- 运行 `gcc -m32 prog.c` 可以在64位机器运行32位机器编译的程序，但是32位不能跑64位的程序
	- ### ==2.1.3 寻址和字节顺序==
		- 小端法：最低有效字节在前   eg：0x01234567，第一位存67
		- 大端法：最高有效字节在前   eg：0x01234567，第一位存01
		- 字节顺序的重要性（常见问题）：
			- 大端与小端机器之间的数据传输->解决方法：特定的网络标准
			- 阅读字节序列
			- 强制类型转换（重点）	
		- 练习2.5：这个练习测试你对数据的字节表示和两种不同字节顺序的理解
		- 练习2.6：整数和浮点表示引入
	- ### ==2.1.4 表示字符串==
		-  注意：十进制数字 x 的 ASCII 码正好是 0x3x, 而终止字节的十六进制表示为 0x00。在使用 ASCII 码 作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文本数据比二进制数据具有更强的平台独立性。
	
	- ### ==2.1.5 表示代码==
		- - 不同的机器类型使用不同的且不兼容的指令和编码方 式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进 制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。
	- ### ==2.1.6 布尔代数简介==
		- ![[Pasted image 20241221204332.png]]
		- 扩展-位向量的运算（忘记了网上搜搜就行）
			- 有趣的结论：a ^ (a ^ b) = b     a ^ a = 0 ^ 0 = 1 ^ 1 = 0
			- 很有用的应用：表示有限集合(这种方法在计算机科学中非常常见，尤其是需要对集合进行高效运算的场景，如布隆过滤器、快速索引等,还有就是信号的屏蔽)
	- ### ==2.1.7 C语言中的位级运算==
		- 练习题2.10：利用位运算实现交换（不需要临时变量）
			- 普通交换：
			```
			void implace_swap(int *x, int *y, int *temp)
			{
				*temp = *x;
				*x = *y;
				*y = *temp;	
			}
			```
			- 利用位运算实现交换：
			```
						void implace_swap(int *x, int *y)
			{
				*y = *x ^ *y;
				*x = *y ^ *y;
				*y = *x ^ *y;	
				//或者一步到位：*x ^= *y ^= *x ^= *y(极其优美)
			}
			```
		- 练习题2.12：掩码相关
			- 一开始没有理解为什么0xFF & x就可以让x的最低有效字节（二进制表示下最低的8位，十六进制表示下最低的2位）保留，其他位为0，其实转化为二进制就好理解了，0xFF = 1111 1111（最低的8位为一），与x按位与也就是让16进制表示的x的最低有效字节不变
			-  剩下的都比较好理解
		- 练习2.13：bis和bic运算（挺有意思的综合性题）
			- 位运算符的重要性质：a ^ b = (a & ~b) | (~a & b)
			- 题解(https://www.cnblogs.com/furzoom/p/CSAPP2_13.html)
	- ### ==2.1.8 C语言中的逻辑运算==
		- 与位级运算区分：逻辑运算认为所有非0参数表示True
			- eg
				- !0x41 = 0x01   
				- ~0x41 = 0xBE
		- 区别2：如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值（之前因为没注意这点在写循环条件时总是出错）
	- ### ==2.1.9 C语言中的移位运算==
		- x << k：x 向左移动 k位，丢弃最高的k位，并在右端补k个 0
		- x >> k：逻辑右移：在左端补k个0 <-> 算数右移：在左端补k个最高有效位的值
			- Q：所以C中如何区分呢？
	- ## ==2.2整数表示==
		- ### ==2.2.1 整型数据类型==
			- 一个很值得注意的特点：负数的范围比正数大1
		- ### ==2.2.2 无符号数的编码==
			- ![[Pasted image 20241222230936.png]]
			- 重要属性：无符号数的编码唯一性 
		- ### ==2.2.3 补码编码==
			- ![[Pasted image 20241222231350.png]]
			- 重要属性：补码编码的唯一性


感觉写标题这样效率还是太低了不适合我,接下来有什么不懂的记什么吧😢

- 强制转换位模式不变
- 0U表示无符号0
- 执行一个运算时,若一个为有符号一个为无符号,有符号会被转换为无符号
- 扩展一个数字的位标识
	- 无符号:零扩展
	- 补码数:符号扩展(扩展时复制最高位就行)
- short转换为unsigned,先会转换成int
- 截断数字看不懂,以后用到了再来看



### 1. **寄存器结构**

- **64位寄存器**：以 `%r` 开头（如 `%rax`、`%rbx` 等），表示64位的完整寄存器。
    
- **32位寄存器**：以 `%e` 开头（如 `%eax`、`%ebx` 等），表示64位寄存器的低32位。
    
- **16位寄存器**：以 `%` 开头（如 `%ax`、`%bx` 等），表示64位寄存器的低16位。
    
- **8位寄存器**：以 `%` 开头（如 `%al`、`%bl` 等），表示64位寄存器的低8位。
    

---

### 2*寄存器用途**

每个寄存器在函数调用和系统操作中有特定的用途：

- **返回值寄存器**：
    
    - `%rax`：用于存储函数返回值。
        
- **参数寄存器**：
    
    - `%rdi`、`%rsi`、`%rdx`、`%rcx`、`%r8`、`%r9`：用于传递函数的前6个参数。
        
- **被调用者保存寄存器**：
    
    - `%rbx`、`%rbp`、`%r12`、`%r13`、`%r14`、`%r15`：在函数调用时，被调用者需要保存这些寄存器的值，并在返回时恢复。
y        
- **调用者保存寄存器**：
    
    - `%r10`、`%r11`：调用者需要保存这些寄存器的值，如果它们在函数调用期间被修改。
        
- **栈指针寄存器**：
    
    - `%rsp`：指向当前栈顶，用于管理函数调用栈。


在x86-64汇编中，**`movzbq` 指令并不存在**。这是因为 x86-64 指令集中没有直接支持从8位零扩展到64位的指令。正确的做法是使用 `movzbl` 将8位数据零扩展到32位，然后利用 x86-64 的特性自动将高32位清零。


对于一个结构体来说，所占据的内存空间必须是最大的类型所需字节的倍数，所以可能需要占据更多的空间
根据这种特点，在设计结构体的时候可以采用一些技巧。例如，要把大的数据类型放到前面

