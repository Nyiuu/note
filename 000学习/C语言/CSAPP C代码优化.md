
### ==代码移动==

如果一个表达式总是得到同样的结果，最好把它移动到循环外面，这样只需要计算一次。编译器有时候可以自动完成，比如说使用 `-O1` 优化。一个例子：

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6|void set_row(double *a, double *b, long i, long n){  <br>    long j;  <br>    for (j = 0; j < n; j++){  <br>        a[n*i + j] = b[j];  <br>    }  <br>}|


这里 `n*i` 是重复被计算的，可以放到循环外面

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5|long j;  <br>int ni = n * i;  <br>for (j = 0; j < n; j++){  <br>    a[ni + j] = b[j];  <br>}|

---
### ==减少计算强度==

用更简单的表达式来完成用时较久的操作，例如 `16*x` 就可以用 `x << 4` 代替，一个比较明显的例子是，可以把乘积转化位一系列的加法，如下：

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5|for (i = 0; i < n; i++){  <br>    int ni = n * i;  <br>    for (j = 0; j < n; j++)  <br>        a[ni + j] = b[j];  <br>}|



可以把 `n*i` 用加法代替，比如：

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6|int ni = 0;  <br>for (i = 0; i < n; i++){  <br>    for (j = 0; j < n; j++)  <br>        a[ni + j] = b[j];  <br>    ni += n;  <br>}|

---
### ==公共子表达式==

可以重用部分表达式的计算结果，例如：

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6|/* Sum neighbors of i, j */  <br>up =    val[(i-1)*n + j  ];  <br>down =  val[(i+1)*n + j  ];  <br>left =  val[i*n     + j-1];  <br>right = val[i*n     + j+1];  <br>sum = up + down + left + right;|

可以优化为

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6|long inj = i*n + j;  <br>up =    val[inj - n];  <br>down =  val[inj + n];  <br>left =  val[inj - 1];  <br>right = val[inj + 1];  <br>sum = up + down + left + right;|

虽然说，现代处理器对乘法也有很好的优化，但是既然可以从 3 次乘法运算减少到只需要 1 次，为什么不这样做呢？蚂蚁再小也是肉嘛。

---
### ==小心过程调用==

我们先来看一段代码，找找有什么问题：

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6|void lower1(char *s){  <br>    size_t i;  <br>    for (i = 0; i < strlen(s); i++)  <br>        if (s[i] >= 'A' && s[i] <= 'Z')  <br>            s[i] -= ('A' - 'a');  <br>}|

问题在于，在字符串长度增加的时候，时间复杂度是二次方的！每次循环中都会调用一次 `strlen(s)`，而这个函数本身需要通过遍历字符串来取得长度，因此时间复杂度就成了二次方。

可以怎么优化呢？简单，那么只计算一次就好了：

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6  <br>7|void lower2(char *s){  <br>    size_t i;  <br>    size_t len = strlen(s);  <br>    for (i = 0; i < len; i++)  <br>        if (s[i] >= 'A' && s[i] <= 'Z')  <br>            s[i] -= ('A' - 'a');  <br>}|

为什么编译器不能自动把这个过程调用给移到外面去呢？

前面说过，编译器的策略必须是保守的，因为过程调用之后所发生的事情是不可控的，所以不能直接改变代码逻辑，比方说，假如 `strlen` 这个函数改变了字符串 `s` 的长度，那么每次都需要重新计算。如果移出去的话，就会导致问题。

所以很多时候只能靠程序员自己进行代码优化。

---
### ==注意内存问题==

接下来我们看另一段代码及其汇编代码

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6  <br>7  <br>8  <br>9  <br>10  <br>11|// 把 nxn 的矩阵 a 的每一行加起来，存到向量 b 中  <br>void sum_rows1(double *a, double *b, long n)  <br>{  <br>    long i, j;  <br>    for (i = 0; i < n; i++)  <br>    {  <br>        b[i] = 0;  <br>        for (j = 0; j < n; j++)  <br>            b[i] += a[i*n + j];  <br>    }  <br>}|

对应的汇编代码为

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6  <br>7  <br>8|# sum_rows1 的内循环  <br>.L4:  <br>    movsd   (%rsi, %rax, 8), %xmm0  # 浮点数载入  <br>    addsd   (%rdi), %xmm0           # 浮点数加  <br>    movsd   %xmm0, (%rsi, %rax, 8)  # 浮点数保存  <br>    addq    $8, %rdi  <br>    cmpq    %rcx, %rdi  <br>    jne     .L4|

可以看到在汇编中，每次都会把 `b[i]` 存进去再读出来，为什么编译器会有这么奇怪的做法呢？因为有可能这里的 `a` 和 `b` 指向的是同一块内存地址，那么每次更新，都会使得值发生变化。但是中间过程是什么，实际上是没有必要存储起来的，所以我们引入一个临时变量，这样就可以消除内存引用的问题。

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6  <br>7  <br>8  <br>9  <br>10  <br>11  <br>12|// 把 nxn 的矩阵 a 的每一行加起来，存到向量 b 中  <br>void sum_rows2(double *a, double *b, long n)  <br>{  <br>    long i, j;  <br>    for (i = 0; i < n; i++)  <br>    {  <br>        double val = 0;  <br>        for (j = 0; j < n; j++)  <br>            val += a[i*n + j];  <br>        b[i] = val;  <br>    }  <br>}|

对应的汇编代码为

|   |   |
|---|---|
|1  <br>2  <br>3  <br>4  <br>5  <br>6|# sum_rows2 内循环  <br>.L10:  <br>    addsd   (%rdi), %xmm0   # 浮点数载入 + 加法  <br>    addq    $9, %rdi  <br>    cmpq    %rax, %rdi  <br>    jne     .L10|

可以看到，加入了临时变量后，解决了奇怪的内存问题，生成的汇编代码干净了许多。

---

### ==处理条件分支==

这个问题，如果不是对处理器执行指令的机制有一定了解的话，可能会难以理解。

现代处理器普遍采用超标量设计，也就是基于流水线来进行指令的处理，也就是说，当执行当前指令时，接下来要执行的几条指令已经进入流水线的处理流程了。

这个很重要，对于顺序执行来说，不会有任何问题，但是对于条件分支来说，在跳转指令时可能会改变程序的走向，也就是说，之前载入的指令可能是无效的。这个时候就只能清空流水线，然后重新进行载入。为了减少清空流水线所带来的性能损失，处理器内部会采用称为『分支预测』的技术。

比方说在一个循环中，根据预测，可能除了最后一次跳出循环的时候会判断错误之外，其他都是没有问题的。这就可以接受，但是如果处理器不停判断错误的话（比方说代码逻辑写得很奇怪），性能就会得到极大的拖累。

分支问题有些时候会成为最主要的影响性能的因素，但有的时候其实很难避免。