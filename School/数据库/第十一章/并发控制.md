# 数据库并发控制学习指南 - 第11章

本指南旨在帮助您理解和记忆数据库并发控制的核心概念。

---

## 1. 为什么需要并发控制？

数据库是共享资源，允许多个用户/事务同时访问和操作。如果对并发操作不加控制，可能会导致数据不一致性问题。

### 常见的数据不一致性问题

*   **丢失修改 (Lost Update)**: 两个事务同时读取并修改同一数据，其中一个事务的修改覆盖了另一个事务的修改，导致后者的修改丢失。
*   **脏读 (Dirty Read)**: 一个事务读取了另一个**未提交**事务修改的数据。如果那个事务后来回滚了，那么第一个事务读取的就是无效的"脏"数据。
*   **不可重复读 (Non-repeatable Read)**: 一个事务内两次读取同一数据，但在此期间有另一个事务修改并提交了该数据，导致两次读取的结果不一致。
*   **幻读 (Phantom Read)**: 一个事务内两次执行相同的范围查询，但在此期间有另一个事务插入或删除了符合查询条件的记录并提交，导致第二次查询返回了额外的"幻影"行或缺少了某些行。

**并发控制的主要任务**就是采用技术和协议来有效地协调并发事务，以确保数据库的一致性，避免上述问题的发生。

---

## 2. 并发调度的可串行性 (Serializability)

**调度**: 指的是多个事务的操作在时间上的交错执行序列。
**串行调度**: 指的是多个事务被一个接一个地串行执行。这种调度是正确的，不会产生数据不一致问题，但效率太低。
**并发调度**: 指的是利用分时的方法，交错执行多个事务的操作。

**可串行性 (Serializability)** 是衡量并发调度正确性的**准则**。

*   **定义**: 如果一个并发调度的执行结果与某个串行调度的执行结果完全相同，那么称这个并发调度是**可串行化**的。
*   **意义**: 可串行性是并发事务能够正确执行的理论基础。我们的目标就是找到一种方法，既能允许事务并发执行以提高效率，又能保证其效果等同于某个串行调度，从而保证数据的一致性。
*   **冲突可串行性**: 一个更实用的判断标准。如果一个并发调度可以通过一系列"非冲突操作"的交换，转换成一个串行调度，则称其为**冲突可串-行化**的。冲突操作指不同事务对同一数据的读-写、写-读、写-写操作。

---

## 3. 封锁 (Locking)

**封锁**是实现并发控制最常用的技术。它通过对事务要操作的数据对象（如记录、表）"加锁"，来确保在特定时间内只有一个事务能以某种方式访问该数据。

### 基本锁类型

*   **排他锁 (Exclusive Lock, X锁)**:
    *   也叫**写锁**。
    *   如果事务T对数据A加上了X锁，则**只允许事务T**读取和修改数据A，**其他任何事务**都不能再对A加任何类型的锁，直到T释放该锁。
    *   **记忆点**: "我写的时候，别人谁也别想动（不能读也不能写）"。

*   **共享锁 (Shared Lock, S锁)**:
    *   也叫**读锁**。
    *   如果事务T对数据A加上了S锁，则**事务T可以读取**但**不能修改**数据A。
    *   **其他事务也可以**对A再加S锁（实现共享读取），但**不能加X锁**，直到所有S锁都被释放。
    *   **记忆点**: "大家可以一起读，但谁也别想改"。

### 锁的兼容矩阵

|       |   X   |   S   |
| :---: | :---: | :---: |
| **X** |  否   |  否   |
| **S** |  否   |  是   |

*   `是`表示兼容，`否`表示冲突。
*   多个事务可对同一数据同时加S锁。
*   一旦某个事务对数据加了X锁，其他事务无法再加任何锁。

---

## 4. 封锁协议 (Locking Protocols)

**封锁协议**是指在运用S锁和X锁对数据对象加锁时，需要遵循的一些规则。这些规则规定了何时申请锁、持续多长时间、何时释放。

*   **一级封锁协议**:
    *   **规则**: 事务T在**修改**数据R之前必须先对其加X锁，**直到事务结束**才释放。
    *   **作用**: 可以防止**丢失修改**。
    *   **问题**: 不能保证不发生脏读和不可重复读。

*   **二级封锁协议**:
    *   **规则**: 在一级协议的基础上，增加事务T在**读取**数据R之前必须先对其加S锁，**读完即可释放**。
    *   **作用**: 可以防止**丢失修改**和**脏读**。
    *   **问题**: 不能保证不发生不可重复读（因为读完就释放S锁，其他事务可以修改）。

*   **三级封锁协议**:
    *   **规则**: 在一级协议的基础上，增加事务T在**读取**数据R之前必须先对其加S锁，**直到事务结束**才释放。
    *   **作用**: 可以防止**丢失修改**、**脏读**和**不可重复读**。

### 两段锁协议 (Two-Phase Locking, 2PL)

**两段锁协议 (2PL)** 是**保证并发调度可串行性**的重要协议。

*   **定义**: 指所有事务必须分两个阶段对数据项加锁和解锁。
    1.  **扩展阶段 (Growing Phase)**: 在此阶段，事务可以申请获得任何数据项上的任何类型的锁，但**不能释放任何锁**。
    2.  **收缩阶段 (Shrinking Phase)**: 在此阶段，事务可以释放任何数据项上的任何类型的锁，但**不能再申请任何新锁**。（不一定有，比如……）

*   **重要定理**: 若所有并发执行的事务都遵守**两段锁协议**，则对这些事务的任何并发调度都是**可串行化**的。

*   **与三级封锁协议的关系**:
    *   遵守两段锁协议的事务，其并发调度一定是可串行化的。
    *   三级封锁协议要求锁必须在事务结束后才释放，这天然满足了2PL的要求（只有扩展阶段，没有收缩阶段），因此三级封锁协议是2PL的一种特殊形式。

---

## 5. 活锁与死锁 (Livelock & Deadlock)

*   **活锁 (Livelock)**:
    *   **描述**: 当一个事务T1反复申请一个被事务T2占用的锁时，可能会陷入一个无尽的等待循环。如果此时有其他事务不断地插入并获得锁，T1可能永远也拿不到锁。
    *   **解决方法**: 采用**先来先服务**的策略，当多个事务等待同一个锁时，按请求顺序进行排队。

*   **死锁 (Deadlock)**:
    *   **描述**: 两个或多个事务形成了一个**循环等待链**，每个事务都在等待另一个事务释放它所需要的锁。例如，T1持有A锁并请求B锁，而T2持有B锁并请求A锁。
    *   **解决方法**:
        1.  **预防**:
            *   **一次封锁法**: 要求每个事务必须一次性将所有要使用的数据全部加锁。缺点是降低并发度。
            *   **顺序封锁法**: 预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。
        2.  **诊断与解除**:
            *   **超时法**: 如果一个事务的等待时间超过了规定的时限，就认为它发生了死锁。
            *   **等待图法**: 系统动态维护一个事务等待图，如果图中出现**环路**，则表示系统出现了死锁。
            *   **解除**: 检测到死锁后，选择一个处理死锁代价最小的事务，将其**撤销**，释放其全部锁，让其他事务得以继续运行。 